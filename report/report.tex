\documentclass{tufte-handout}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{float}
\usepackage{longtable}
\usepackage{adjustbox}

\usepackage{color}
\newcommand{\red}[1]{{\color{red} #1}}
\usepackage{booktabs}

\begin{document}
\section{Red Scare! Report}

by Andreas Tietgen (anti), Albert Rise Nielsen (albn) and Amalie Bøgild Sørensen (abso).

\subsection{Results}

The following table gives our results for all graphs of at least 500 vertices.

\medskip
\begin{longtable}{lrrrrrr}
\toprule
	Instance name & $n$ & A & F & M & N & S\\
	\midrule
	G-ex & 8 & true & 0 & ?! & 3 & ?!\\
	P3 & 3 & true & 1 & ?! & -1 & true\\
	common-1-100 & 100 & false & -1 & ?! & -1 & ?!\\
	common-1-20 & 20 & false & -1 & -1 & -1 & false\\
	common-1-250 & 250 & false & -1 & ?! & -1 & ?!\\
	common-1-50 & 50 & false & -1 & ?! & -1 & ?!\\
	common-1-500 & 500 & false & -1 & ?! & -1 & ?!\\
	common-2-100 & 100 & false & -1 & ?! & -1 & ?!\\
	common-2-20 & 20 & false & -1 & ?! & -1 & ?!\\
	common-2-250 & 250 & false & -1 & ?! & -1 & ?!\\
	common-2-50 & 50 & false & -1 & ?! & -1 & ?!\\
	common-2-500 & 500 & true & 1 & ?! & 4 & true\\
	dodecahedron & 20 & false & 1 & ?! & 1 & true\\
	gnm-10-15-0 & 10 & false & 0 & ?! & 1 & ?!\\
	gnm-10-15-1 & 10 & true & 0 & ?! & 1 & ?!\\
	gnm-10-20-0 & 10 & false & 0 & ?! & 3 & ?!\\
	gnm-10-20-1 & 10 & true & 1 & ?! & 3 & true\\
	grid-10-0 & 100 & false & 0 & ?! & 49 & ?!\\
	grid-10-1 & 100 & false & 0 & ?! & 29 & ?!\\
	grid-10-2 & 100 & true & 2 & ?! & -1 & true\\
	grid-5-0 & 25 & true & 0 & ?! & 14 & ?!\\
	grid-5-1 & 25 & true & 0 & ?! & 8 & ?!\\
	grid-5-2 & 25 & true & 1 & ?! & -1 & true\\
	increase-n10-1 & 10 & true & 1 & 1 & 1 & true\\
	increase-n10-2 & 10 & true & 1 & 2 & 1 & true\\
	increase-n10-3 & 10 & false & -1 & -1 & -1 & false\\
	increase-n100-1 & 100 & false & -1 & -1 & -1 & false\\
	increase-n100-2 & 100 & true & 1 & 12 & 1 & true\\
	increase-n100-3 & 100 & false & -1 & -1 & -1 & false\\
	increase-n20-1 & 20 & false & -1 & -1 & -1 & false\\
	increase-n20-2 & 20 & true & 0 & 5 & 1 & true\\
	increase-n20-3 & 20 & false & -1 & -1 & -1 & false\\
	increase-n50-1 & 50 & false & -1 & -1 & -1 & false\\
	increase-n50-2 & 50 & true & 1 & 4 & 1 & true\\
	increase-n50-3 & 50 & true & 1 & 3 & 1 & true\\
	increase-n500-1 & 500 & true & 1 & 15 & 1 & true\\
	increase-n500-2 & 500 & true & 1 & 16 & 1 & true\\
	increase-n500-3 & 500 & true & 1 & 15 & 1 & true\\
	increase-n8-1 & 8 & true & 1 & 1 & 1 & true\\
	increase-n8-2 & 8 & true & 0 & 1 & 1 & true\\
	increase-n8-3 & 8 & true & 0 & 1 & 1 & true\\
	rusty-1-17 & 17 & false & 0 & ?! & 10 & ?!\\
	ski-illustration & 36 & false & 0 & 1 & 8 & true\\
	ski-level10-1 & 79 & false & -1 & -1 & -1 & false\\
	ski-level10-2 & 76 & false & 1 & 4 & -1 & true\\
	ski-level10-3 & 77 & false & 4 & 7 & -1 & true\\
	ski-level20-1 & 252 & false & 3 & 10 & -1 & true\\
	ski-level20-2 & 253 & false & 9 & 13 & -1 & true\\
	ski-level20-3 & 254 & false & -1 & -1 & -1 & false\\
	ski-level3-1 & 16 & true & 0 & 3 & 5 & true\\
	ski-level3-2 & 14 & false & 0 & 1 & 5 & true\\
	ski-level3-3 & 15 & false & 0 & 1 & 5 & true\\
	ski-level5-1 & 29 & false & 1 & 3 & -1 & true\\
	ski-level5-2 & 26 & false & 1 & 2 & -1 & true\\
	ski-level5-3 & 27 & false & 0 & 0 & 7 & false\\
	smallworld-10-0 & 100 & false & 0 & ?! & 6 & ?!\\
	smallworld-10-1 & 100 & true & 0 & ?! & 8 & ?!\\
	smallworld-20-0 & 400 & false & 0 & ?! & 8 & ?!\\
	smallworld-20-1 & 400 & true & 0 & ?! & 14 & ?!\\
	smallworld-3-0 & 9 & false & 0 & ?! & 4 & ?!\\
	smallworld-3-1 & 9 & false & 1 & ?! & 2 & true\\
	wall-n-1 & 8 & false & 0 & ?! & 1 & ?!\\
	wall-n-10 & 80 & false & 0 & ?! & 1 & ?!\\
	wall-n-2 & 16 & false & 0 & ?! & 1 & ?!\\
	wall-n-3 & 24 & false & 0 & ?! & 1 & ?!\\
	wall-n-4 & 32 & false & 0 & ?! & 1 & ?!\\
	wall-p-1 & 8 & false & 0 & ?! & 1 & ?!\\
	wall-p-10 & 62 & false & 0 & ?! & 1 & ?!\\
	wall-p-2 & 14 & false & 0 & ?! & 1 & ?!\\
	wall-p-3 & 20 & false & 0 & ?! & 1 & ?!\\
	wall-p-4 & 26 & false & 0 & ?! & 1 & ?!\\
	wall-z-1 & 8 & false & 0 & ?! & 1 & ?!\\
	wall-z-10 & 71 & false & 0 & ?! & 1 & ?!\\
	wall-z-2 & 15 & false & 0 & ?! & 1 & ?!\\
	wall-z-3 & 22 & false & 0 & ?! & 1 & ?!\\
	wall-z-4 & 29 & false & 0 & ?! & 1 & ?!\\

	\bottomrule
\end{longtable}
\medskip

The columns are for the problems Alternate, Few, Many, None, and Some.
The table entries either give the answer, or contain `?' for those cases where we were unable to find a solution within reasonable time.
For those questions where there is a reason for our inability to find a good algorithm (because the problem is hard), we wrote `?!'.

For the complete table of all results, including time, see the tab-separated text file {\tt results.txt} or the appendix.

\subsection{Methods}
For problem A, we've used a modified version of the BFS algorithm to find an alternating path from $s$ to $t$. Depending on the color of the start vertex the algorithm queues edges that leads to a different color than the current and discards edges that leads to a vertex with the same color. In the case where the queue of alternating vertices are empty without finding an alternating path to the end vertex, the algorithm will return 'false'. However, in the case where it finds the end vertex with a different color than the current visited vertex, the algorithm will return 'true'
Looking at the running time of this algorithm it is O(V+E), the same as Breadth-first search (BFS).

For problem F we've solved each instance with Dijkstra's algorithm to find the path containing the fewest amount of red vertices. We've achieved this by assigning each edge entering a red vertex a weight of 1. Every other edge is assigned a weight of 0. Thereby the path with the smallest cost to get from $s$ to $t$ must be the one that enters the fewest red vertices. Since Dijkstra only allows simple paths, the cost of the path must also be the total amount of red vertices that the path enters. Therefore the cost to get to $t$ is the total red vertices the path enters. In case there is no path from $s$ to $t$ the cost to get to $t$ will be $sys.maxsize$.

For problem M, we first check that the graph is directed and contains no cycles. This is because the problem can’t be solved if there is a cycle and for undirected graphs. Thus the problem is NP-hard. On the other hand, if the graph is directed and with no cycles we compute a topological sorting starting from the start node. That is, any nodes pointing to the start node will not
 be part of the topological sorting. We do this with Depth-first search (DFS) by including a boolean “is\_back” tag in the stack we pop from. If the tag on the current node is true we know that all nodes that can be reached from the current node have been visited, and thus we can add the node to our topological sorting. The result will thus be a reverse topological sorting, 
such that we can pop from the sorting in order to obtain the first node in the topological sorting. When returning from the topological sorting, we also check whether the target node is in visited, since then we know that there exists a path from start to target. If this is not the case we can safely return
 -1. If there is a path going from start to end vertex, we can run the longest chain algorithm in order to find the path containing the most red vertices: We pop from the topological sorting and define ‘a’ as 1 if this node is red, otherwise 0. We then visit all neighbours and update their entry in the dist array: if the distance to our current node + a is bigger
 than what is currently stored, we set the dist to exactly the distance to our current node + a. In this way we make sure that we get the chain with the most red vertices. Furthermore, we use memoization as we save the current computed dist to all vertices and reuse this in other compuations. At last, we return the dist stored for the target node, which is the maximum number of red vertices on any path from start to target. The runtime of M is O(V+E) where V are the vertices and E are the edges.
 
As stated we could not solve the problem in the instances where the graph is undirected or contains a cycle. This is due to the problem, being NP-Hard, as can be seen by the following reduction from the Longest Simple Path Problem i.e. Longest Simple Path Problem $\leq_p$ Some: In order to see this, consider a graph $G(V,E)$. The longest path algorithm can be reduced to the Many problem by setting all verticies, $V(G)$, to be red. By the nature of the Many problem, the output would be a path with the most red vertices, which is the same as the longest path. 

For problem N, we solved it by doing a BFS while avoiding to queue any red vertices unless it is the target node. BFS is guaranteed
to find the shortest path which is what we are trying to achieve here.
The runtime of BFS is O(V*E) where V are the number of vertices and E is the number of edges.

For problem S, we partly depend on the answers from Many and Few, since if the graph is directed then we can reduce it to Many. If any of the answers to these are > 0, then we can safely return true for Some. Also if the answer to Many is 0 then we can return false. If the graph is acyclic we run DFS to find a path from start to target. The DFS is implemented such that it counts the number of red vertices on the path we're currently exploring. Since DFS explores the entire graph, then it must find a path with one or more red vertices from start to target, if such a path exists. 
The runtime for DFS is O(V+E) where V are the number of vertices and E is the number of edges. 

In the case of a cyclic graph we won't be able to solve Some, since it is NP-hard. We can reduce the problem to a variant of the Subgraph Homeomorphism Problem (SHP) [1], which is NP-hard in the case of a cycle (omitting some specific cases), which further reduces to 3-CNF. Showing 3-CNF $\leq_p$ SHP $\leq_p$ Some is outside of the parameters of this assignment.

\subsection{References}
\begin{description}
  \item[1.] Steven Fortune, John Hopcroft, James Wyllie \emph{The directed subgraph homeomorphism problem}, Theoretical Computer Science \textit{Volume 10, Issue 2} 1980. 
\end{description}



\subsection{Appendix}
\textbf{All results}
\input{results.tex}

\end{document}

