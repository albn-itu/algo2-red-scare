\documentclass{tufte-handout}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{amsmath}

\usepackage{color}
\newcommand{\red}[1]{{\color{red} #1}}
\usepackage{booktabs}
\begin{document}
\section{Red Scare! Report}

by Andreas Tietgen (anti), Albert Rise Nielsen (albn) and Amalie Bøgild Sørensen (abso).

\subsection{Results}

The following table gives our results for all graphs of at least 500 vertices.

\medskip
\begin{tabular}{lrrrrrr}
  \toprule
  Instance name & $n$ & A & F & M & N & S \\
  \midrule
  rusty-5762 & 5,762 & true & 16 & -- & ? & 5 \\
  wall-p-10000 & 10,000 &\\	
  $\vdots$\\
  \bottomrule
\end{tabular}
\medskip

The columns are for the problems Alternate, Few, Many, None, and Some.
The table entries either give the answer, or contain `?' for those cases where we were unable to find a solution within reasonable time.
For those questions where there is a reason for our inability to find a good algorithm (because the problem is hard), we wrote `?!'.

For the complete table of all results, see the tab-separated text file {\tt results.txt}.

\subsection{Methods}

For problem A, we've used a modified version of the BFS algorihtm to find an alternating path from $s$ to $t$. Depending on the color of the start vertex the algorithm chooses edges that leads to a different color than the current and discards edges that leads to a vertex with the same color. If none of the adjacent vertices has another color, the algorithm will try to explore some of the other vertices that has been queued until none is left. At this point the algorihtm will return 'false'. In the case where the algorithm finds the alternating path it returns 'true'.
The running time of this algorithm is O(V+E).
I solved problem $\cdots$ for all $\cdots$\footnote{For instance, “planar, bipartite”} graphs using $\cdots$.

I was unable to solve problem $\cdots$ except for the $\cdots$ instances.
This is because, in generality, this problem is $\cdots$. 
To see this, consider the following reduction from $\cdots$.
Let $\ldots$ 

I was also unable to solve $\cdots$ for $\cdots$, but I don’t know why.\footnote{Remove or expand as necessary.}

For problem F we've solved each instance with Dijkstra's algorithm to find the path containing the fewest amount of red vertices. We've achieved this by assigning each edge entering a red vertex a weight of 1. Every other edge is assigned a vertex of 0. Thereby the path with the smallest cost to get from $s$ to $t$ must be the one that enters the fewest red vertices. Since Dijkstra only allows simple paths, the cost of the path must also be the total amount of red vertices that the path enters. Therefore the cost to get to $t$ is the total red vertices the path enters. In case there is no path from $s$ to $t$ the cost to get to $t$ will be $sys.maxsize$.

For problem M...

For problem N, we solved it by doing a BFS while avoiding to queue any red vertices unless it is the target node. BFS is guaranteed
to find the shortest path which is what we are trying to achieve here.
The runtime of BFS is O(V*E) where V are the number of vertices and E is the number of edges.

For problem S, we used the answer from problem M. Since problem M returns the maximum number of red nodes on a path from s to t we know that if this is > 0, we have
to return True and otherwise False for problem S. Thus, the Some problem reduces to the Many problem.
For that reason the runtime is the same as for problem M. 

\subsection{References}
\begin{description}
  \item[1.] \emph{APLgraphlib---A library for Basic Graph Algorithms in APL}, version 2.11, 2016, Iverson Project, {\tt github.com/iverson/APLgraphlib}.\sidenote{If you use references to code, books, or papers, be professional about it. Use whatever style you want, but be consistent.}

  \item[2.] A. Lovelace, \emph{Algorithms and Data Structures in Pascal}, Addison--Wesley 1881. 
\end{description}

\end{document}

